import * as xmljs from 'xml-js';
import { CTypeEnum } from '../enums/CTypeEnum'; 

// Helper interface to mimic the structure of the PHP XmlParser's node object
interface AdaptedXmlNode {
    tagName: string;
    attributes: Record<string, string>;
    has_children: boolean;
    inner_html: AdaptedXmlNode[];
    nodeString: string; // String representation of the node, generated by js2xml
    isSelfClosed: boolean; // True if the original tag was like <tag/>
}

// Options for xml-js parsing
const XML_PARSE_OPTIONS: xmljs.Options.XML2JS = {
    compact: false,
    alwaysArray: true, // Ensures elements are always in an array
    trim: false, // Preserve whitespace if important
    // elementsKey: 'elements', // Default
    // attributesKey: 'attributes', // Default
    // textKey: 'text', // Default
};

// Options for xml-js generation
const XML_GEN_OPTIONS_NODE: xmljs.Options.JS2XML = {
    compact: false,
    spaces: 0,
};

export class DataRefReplacer {
    private map: Map<string, string>;

    constructor(map: Record<string, string | null | undefined> = {}) {
        this.map = new Map(Object.entries(this.sanitizeMap(map)));
    }

    private sanitizeMap(map: Record<string, any>): Record<string, string> {
        const sanitized: Record<string, string> = {};
        for (const name in map) {
            if (Object.prototype.hasOwnProperty.call(map, name)) {
                const value = map[name];
                if (value === null || value === '' || typeof value === 'undefined') {
                    sanitized[name] = 'NULL';
                } else {
                    sanitized[name] = String(value);
                }
            }
        }
        return sanitized;
    }

    private getAttribute(attributes: Record<string, string>, key: string, defaultValue?: string): string | undefined {
        return attributes.hasOwnProperty(key) ? attributes[key] : defaultValue;
    }

    private getMapValue(key: string | undefined | null, defaultValue: string = 'NULL'): string {
        if (key === null || typeof key === 'undefined') return defaultValue;
        return this.map.has(key) ? this.map.get(key) as string : defaultValue;
    }

    /**
     * Transforms an xml-js element object into our AdaptedXmlNode structure.
     * This is a recursive function.
     */
    private transformElementToAdaptedNode(element: xmljs.Element): AdaptedXmlNode | null {
        if (element.type !== 'element' || !element.name) {
            return null;
        }

        const attributes: Record<string, string> = {};
        if (element.attributes) {
            for (const key in element.attributes) {
                if (Object.prototype.hasOwnProperty.call(element.attributes, key)) {
                     attributes[key] = String(element.attributes[key]);
                }
            }
        }

        const inner_html: AdaptedXmlNode[] = [];
        // An element is considered self-closed if its 'elements' array is UNDEFINED.
        // If 'elements' is an empty array [], it means <tag></tag>.
        const isSelfClosed = typeof element.elements === 'undefined';

        if (element.elements) { // Process children only if 'elements' array exists
            for (const childElement of element.elements) {
                const adaptedChild = this.transformElementToAdaptedNode(childElement);
                if (adaptedChild) {
                    inner_html.push(adaptedChild);
                }
            }
        }
        
        // Generate nodeString using js2xml.
        // This is critical: it reconstructs the XML string for the node.
        // It might not be *identical* to the original substring from the input XML.
        const nodeStringOptions: xmljs.Options.JS2XML = {
            ...XML_GEN_OPTIONS_NODE,
            // If self-closed, we want <tag/> (fullTagEmptyElement=false).
            // If <tag></tag>, we want that (fullTagEmptyElement=true).
            fullTagEmptyElement: !isSelfClosed,
        };
        const nodeString = xmljs.js2xml({ elements: [element] }, nodeStringOptions).trim();

        return {
            tagName: element.name,
            attributes: attributes,
            has_children: inner_html.length > 0,
            inner_html: inner_html,
            nodeString: nodeString,
            isSelfClosed: isSelfClosed,
        };
    }

    /**
     * Parses an XML string (potentially a fragment) into an array of AdaptedXmlNode.
     * Wraps the string in a dummy root to help xml-js parse fragments.
     */
    private parseXmlStringToAdaptedNodes(xmlString: string): AdaptedXmlNode[] {
        try {
            // Wrap in a dummy root to handle fragments or multiple top-level elements
            const wrappedXml = `<dummyRoot>${xmlString}</dummyRoot>`;
            const parsedJs = xmljs.xml2js(wrappedXml, XML_PARSE_OPTIONS) as xmljs.Element;

            // Children of dummyRoot are the actual top-level elements
            const rootElements = parsedJs.elements?.[0]?.elements;
            if (!rootElements) return [];

            const adaptedNodes: AdaptedXmlNode[] = [];
            for (const el of rootElements) {
                const adapted = this.transformElementToAdaptedNode(el);
                if (adapted) {
                    adaptedNodes.push(adapted);
                }
            }
            return adaptedNodes;
        } catch (e) {
            // console.warn("XML parsing error in parseXmlStringToAdaptedNodes:", e);
            return []; // Mimic PHP's tendency to not throw for bad segments
        }
    }


    public replace(originalString: string): string {
        if (this.map.size === 0 || !this.hasAnyDataRefAttribute(originalString)) {
            return originalString;
        }

        let currentString = originalString;

        try {
            const adaptedNodes = this.parseXmlStringToAdaptedNodes(currentString);
            if (!adaptedNodes.length && currentString.includes("dataRef")) {
                 // If parsing failed but dataRef is present, it might be due to very malformed XML
                 // The PHP version might proceed with regex in some cases.
                 // Here, we'd return original string if initial parse yields nothing.
            }

            const dataRefEndMap: Array<{ id?: string; dataRefEnd?: string }> = [];

            for (const node of adaptedNodes) {
                currentString = this.recursiveTransformDataRefToPhTag(node, currentString);
                currentString = this.recursiveReplaceSelfClosedPcTags(node, currentString);
                this.extractDataRefMapRecursively(node, currentString, dataRefEndMap);
            }

            currentString = this.replaceOpeningPcTags(currentString);
            currentString = this.replaceClosingPcTags(currentString, dataRefEndMap);

        } catch (ignore) {
            // If something fails, return the original string
            // console.warn("Error during DataRefReplacer.replace:", ignore);
        }
        return currentString;
    }

    private hasAnyDataRefAttribute(str: string): boolean {
        const regex = /(dataRef|dataRefStart|dataRefEnd)=['"].*?['"]/;
        return regex.test(str);
    }

    private recursiveTransformDataRefToPhTag(node: AdaptedXmlNode, currentFullString: string): string {
        let newFullString = currentFullString;

        if (node.has_children) {
            for (const childNode of node.inner_html) {
                newFullString = this.recursiveTransformDataRefToPhTag(childNode, newFullString);
            }
        } else {
            let ctype: CTypeEnum | undefined;
            switch (node.tagName) {
                case 'ph': ctype = CTypeEnum.PH_DATA_REF; break;
                case 'sc': ctype = CTypeEnum.SC_DATA_REF; break;
                case 'ec': ctype = CTypeEnum.EC_DATA_REF; break;
                default: return newFullString;
            }

            const dataRefValue = this.getAttribute(node.attributes, 'dataRef');
            if (!dataRefValue || !this.map.has(dataRefValue)) {
                return newFullString;
            }

            const id = this.getAttribute(node.attributes, 'id', dataRefValue);
            const mappedValue = this.getMapValue(dataRefValue);

            // IMPORTANT: node.nodeString is the re-serialized XML from xml-js.
            // If it differs from the original PHP's $node->node, replacement might fail.
            return this.replaceNewTagString(
                node.nodeString, // actualNodeString (original tag string)
                id,
                mappedValue,
                ctype,
                newFullString, // originalString (the full current string)
                null // upCountIdValue from PHP, seems to be null here
            );
        }
        return newFullString;
    }

    private recursiveReplaceSelfClosedPcTags(node: AdaptedXmlNode, currentFullString: string): string {
        let newFullString = currentFullString;

        if (node.has_children) {
            for (const childNode of node.inner_html) {
                newFullString = this.recursiveReplaceSelfClosedPcTags(childNode, newFullString);
            }
        } else if (node.tagName === 'pc' && node.isSelfClosed) { // isSelfClosed checks if it was <pc ... />
            const dataRefStartAttr = this.getAttribute(node.attributes, 'dataRefStart');
            if (dataRefStartAttr && this.map.has(dataRefStartAttr)) {
                const mappedValue = this.getMapValue(dataRefStartAttr);
                const id = this.getAttribute(node.attributes, 'id');

                return this.replaceNewTagString(
                    node.nodeString,
                    id,
                    mappedValue,
                    CTypeEnum.PC_SELF_CLOSE_DATA_REF,
                    newFullString
                );
            }
        }
        return newFullString;
    }
    
    private extractDataRefMapRecursively(
        node: AdaptedXmlNode,
        completeString: string, // The current full string
        dataRefEndMap: Array<{ id?: string; dataRefEnd?: string }>
    ): void {
        if (node.has_children) {
            node.inner_html.forEach(nestedNode => {
                this.extractDataRefMapRecursively(nestedNode, completeString, dataRefEndMap);
            });
        }

        // PHP: $isATagPairWithEmptyTextNode = strpos( $completeString, substr( $node->node, 0, -2 ) . '></pc>' ) !== false;
        // This is very hard to replicate reliably if node.nodeString is re-serialized.
        // node.isSelfClosed being false means it was <pc ...></pc> (even if empty).
        // The PHP logic `($node->self_closed === false || $isATagPairWithEmptyTextNode)` tries to catch both
        // explicit pairs and self-closed tags that should be treated as pairs.
        // Our `!node.isSelfClosed` covers `<pc></pc>`.
        // The `isATagPairWithEmptyTextNode` is tricky. For now, we rely on `!node.isSelfClosed`.
        if (node.tagName === 'pc' && !node.isSelfClosed) {
            const id = this.getAttribute(node.attributes, 'id');
            const dataRefStart = this.getAttribute(node.attributes, 'dataRefStart');
            const dataRefEnd = this.getAttribute(node.attributes, 'dataRefEnd', dataRefStart);

            dataRefEndMap.push({
                id: id,
                dataRefEnd: dataRefEnd,
            });
        }
    }

    private replaceOpeningPcTags(currentFullString: string): string {
        let newFullString = currentFullString;
        // Regex to find opening <pc ...> tags.
        // PHP: |<pc ([^>/]+?)>|iu
        const openingPcRegex = /<pc([^>/]*?)>/gi; // Simplified, ensure attributes are captured correctly
                                                 // A more robust regex might be needed for complex attributes

        let match;
        const matches = [];
        // Store matches because modifying string in loop invalidates regex indices
        while((match = openingPcRegex.exec(newFullString)) !== null) {
            matches.push(match);
        }

        for (const pcMatch of matches) {
            const openingTagString = pcMatch[0]; // The full opening tag e.g. <pc id="1" dataRefStart="foo">
            // const attributesString = pcMatch[1]; // The attributes part

            // Parse this specific opening tag (by making it temporarily well-formed)
            // to extract its attributes reliably.
            const tempXmlToParse = `${openingTagString}</pc>`;
            const parsedNodes = this.parseXmlStringToAdaptedNodes(tempXmlToParse);
            if (!parsedNodes || parsedNodes.length === 0) continue;
            
            const node = parsedNodes[0]; // This is the <pc> node

            let dataRefStart = this.getAttribute(node.attributes, 'dataRefStart');
            let dataRefEnd = this.getAttribute(node.attributes, 'dataRefEnd');

            if (typeof dataRefEnd !== 'undefined' && typeof dataRefStart === 'undefined') {
                dataRefStart = dataRefEnd;
            } else if (typeof dataRefStart !== 'undefined' && typeof dataRefEnd === 'undefined') {
                dataRefEnd = dataRefStart;
            }
            // Update node.attributes for consistency if needed, though we use dataRefStart directly
            // node.attributes['dataRefStart'] = dataRefStart;
            // node.attributes['dataRefEnd'] = dataRefEnd;


            if (typeof dataRefStart !== 'undefined') {
                const id = this.getAttribute(node.attributes, 'id');
                const mappedValue = this.getMapValue(dataRefStart);

                // IMPORTANT: Use the original matched openingTagString for replacement,
                // not node.nodeString from the parsed temp XML.
                newFullString = this.replaceNewTagString(
                    openingTagString, // actualNodeString is the originally matched opening tag
                    id,
                    mappedValue,
                    CTypeEnum.PC_OPEN_DATA_REF,
                    newFullString
                );
            }
        }
        return newFullString;
    }

    private replaceClosingPcTags(currentFullString: string, dataRefEndMap: Array<{ id?: string; dataRefEnd?: string }>): string {
        let newFullString = currentFullString;
        const closingPcRegex = /<\/pc>/gi;
        
        const matches: Array<{index: number, originalText: string}> = [];
        let match;
        while((match = closingPcRegex.exec(newFullString)) !== null) {
            matches.push({index: match.index, originalText: match[0]});
        }

        // Iterate in reverse order of matches to handle index changes correctly
        // due to replacements of varying lengths.
        // The PHP code uses a delta. Iterating backwards is simpler here.
        for (let i = matches.length - 1; i >= 0; i--) {
            const currentMatch = matches[i];
            const mapEntryIndex = i; // Assuming direct correspondence with dataRefEndMap order
                                     // This relies on dataRefEndMap being built in the same order as </pc> tags appear.

            const attr = dataRefEndMap[mapEntryIndex];

            if (attr && typeof attr.dataRefEnd !== 'undefined') {
                const mappedValue = this.getMapValue(attr.dataRefEnd);
                const newTag = this.getNewTagString(
                    currentMatch.originalText, // '</pc>'
                    attr.id,
                    mappedValue,
                    CTypeEnum.PC_CLOSE_DATA_REF,
                    '_2' // upCountIdValue
                );
                
                newFullString = newFullString.substring(0, currentMatch.index) +
                                newTag +
                                newFullString.substring(currentMatch.index + currentMatch.originalText.length);
            }
        }
        return newFullString;
    }


    public restore(originalString: string): string {
        if (this.map.size === 0) { // PHP used empty(), map.size === 0 is equivalent for TS Map
            return originalString;
        }

        let currentString = originalString;
        try {
            const adaptedNodes = this.parseXmlStringToAdaptedNodes(currentString);

            for (const node of adaptedNodes) {
                currentString = this.recursiveRestoreOriginalTags(node, currentString);
            }
        } catch (e) {
            // console.warn("Error during restore:", e);
        }
        return currentString;
    }

    private recursiveRestoreOriginalTags(node: AdaptedXmlNode, currentFullString: string): string {
        let newFullString = currentFullString;

        if (node.has_children) {
            for (const childNode of node.inner_html) {
                newFullString = this.recursiveRestoreOriginalTags(childNode, newFullString);
            }
        } else {
            const xOrig = this.getAttribute(node.attributes, 'x-orig');
            if (!xOrig) {
                return newFullString;
            }

            const ctype = this.getAttribute(node.attributes, 'ctype') as CTypeEnum; // Cast if sure
            
            // Assuming CTypeEnum has a static method or you have a helper
            // For now, directly check if ctype is one of the layer 2 constants.
            // This needs to be adapted based on your CTypeEnum definition.
            const isLayer2 = [
                CTypeEnum.PH_DATA_REF, CTypeEnum.SC_DATA_REF, CTypeEnum.EC_DATA_REF,
                CTypeEnum.PC_OPEN_DATA_REF, CTypeEnum.PC_CLOSE_DATA_REF, CTypeEnum.PC_SELF_CLOSE_DATA_REF
            ].includes(ctype);


            if (isLayer2) { // Check if CTypeEnum.isLayer2Constant(ctype)
                const originalTag = Buffer.from(xOrig, 'base64').toString('utf-8');
                
                // PHP: preg_replace( '/' . preg_quote( $node->node, '/' ) . '/', ..., $string, 1 );
                // This replaces the first occurrence of node.nodeString.
                // node.nodeString is the re-serialized form of the <ph> tag.
                // This relies on node.nodeString accurately representing the tag to be replaced.
                const escapedNodeString = node.nodeString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedNodeString);
                
                if (regex.test(newFullString)) {
                    newFullString = newFullString.replace(regex, originalTag);
                } else {
                    // Fallback or warning if the exact nodeString isn't found.
                    // This can happen if serialization of <ph> doesn't match what's in the string.
                    // The PHP code's str_replace in replaceNewTagString might also face this if
                    // actualNodeString (from node.nodeString) is subtly different.
                }
            }
        }
        return newFullString;
    }

    private getNewTagString(
        actualNodeString: string, // Original string of the tag being replaced
        id: string | undefined,
        dataRefValue: string,
        ctype: CTypeEnum,
        upCountIdValue: string | null = null
    ): string {
        const newTagParts: string[] = ['<ph'];

        if (typeof id !== 'undefined') {
            newTagParts.push(`id="${id}${upCountIdValue || ''}"`);
        }
        newTagParts.push(`ctype="${ctype}"`);
        newTagParts.push(`equiv-text="base64:${Buffer.from(dataRefValue).toString('base64')}"`);
        newTagParts.push(`x-orig="${Buffer.from(actualNodeString).toString('base64')}"`);

        return newTagParts.join(" ") + '/>';
    }

    private replaceNewTagString(
        actualNodeString: string, // The exact string of the node/tag to be replaced
        id: string | undefined,
        dataRefValue: string,
        ctype: CTypeEnum,
        originalFullString: string,
        upCountIdValue: string | null = '_1' // Default from PHP, but recursiveTransformDataRefToPhTag passes null
    ): string {
        const newTag = this.getNewTagString(actualNodeString, id, dataRefValue, ctype, upCountIdValue);
        // Replace only the first occurrence, like PHP's str_replace without count or preg_replace with limit 1.
        // String.prototype.replace with a string argument only replaces the first match.
        if (originalFullString.includes(actualNodeString)) {
            return originalFullString.replace(actualNodeString, newTag);
        }
        // console.warn(`Actual node string not found for replacement: ${actualNodeString}`);
        return originalFullString; // If not found, return original (PHP behavior)
    }
}

